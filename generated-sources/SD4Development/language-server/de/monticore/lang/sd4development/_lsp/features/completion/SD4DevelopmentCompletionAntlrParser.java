/* generated by template _lsp.features.completion.CompletionAntlrParser*/

package de.monticore.lang.sd4development._lsp.features.completion;

import de.monticore.lang.sd4development._lsp.SD4DevelopmentLspAntlrParser;
import de.mclsg.atn.StateWithContext;
import de.mclsg.lsp.features.completion.parser.*;
import de.monticore.ast.ASTNode;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.atn.ATNState;
import org.antlr.v4.runtime.atn.Transition;
import de.mclsg.parser.MatchedToken;

import java.util.*;
import java.util.function.Predicate;

public class SD4DevelopmentCompletionAntlrParser extends SD4DevelopmentLspAntlrParser implements CompletionLspParser {
    private StateWithContext[] firstStatesOfParserCompletion;
    private AutocompletionErrorStrategy completionErrorStrategy;

    public SD4DevelopmentCompletionAntlrParser(TokenStream input) {
        super(input);
        completionErrorStrategy = new AutocompletionErrorStrategy();
        this.setErrorHandler(completionErrorStrategy);
        ATNState firstState = getFirstState();
        this.firstStatesOfParserCompletion = new StateWithContext[]{new StateWithContext(firstState, super._ctx)};
    }

    @Override
    public Token match(int ttype) throws RecognitionException {
        Token matchedToken = super.match(ttype);
        if (isNotEOF(matchedToken)) {
            int currentState = getState();
            this.firstStatesOfParserCompletion = getStateAfterTransitionLabeledWithToken(currentState, matchedToken);
        }
        return matchedToken;
    }

    /**
     * Returns all information about the last token this parser matched in form of a {@link MatchedToken}.
     * Can be any kind of token => is not guaranteed to be a Name token
     */
    public MatchedToken getLastToken(){
        List<MatchedToken> matchedTokens = getMatchedTokens();
        return matchedTokens.isEmpty() ? null : matchedTokens.get(matchedTokens.size() - 1);
    }

    private boolean isNotEOF(Token matchedToken) {
        return matchedToken.getTokenIndex() >= 0;
    }

    private StateWithContext[] getStateAfterTransitionLabeledWithToken(int state, Token matchedToken) {
        ATNState atnStateBeforeMatchedToken = getStateFromStateIndex(state);
        return Arrays.stream(atnStateBeforeMatchedToken.getTransitions())
                .filter(transitionsWithMatchedTokenAsLabel(matchedToken))
                .map(this::transitionToSuccessorState)
                .map(this::successorStateToStateWithContext)
                .toArray(StateWithContext[]::new);
    }

    private StateWithContext successorStateToStateWithContext(ATNState successorState) {
        return new StateWithContext(successorState, getContext());
    }

    private ATNState transitionToSuccessorState(Transition transition) {
        return transition.target;
    }

    private Predicate<Transition> transitionsWithMatchedTokenAsLabel(Token matchedToken) {
        return transition -> transition.label().contains(matchedToken.getType());
    }

    private ATNState getStateFromStateIndex(int state) {
        return getATN().states.get(state);
    }

    public StateWithContext[] getFirstStatesOfParserCompletion() {
        return Arrays.stream(firstStatesOfParserCompletion)
                .map(stateWithContext -> isEpsilonSuccessorOfDecision(stateWithContext.state.stateNumber) ? getPrecedingDecisionState() : stateWithContext)
                .toArray(StateWithContext[]::new);
    }

    @Override
    public void setLastStates(StateWithContext[] states) {
        this.firstStatesOfParserCompletion = states;
    }

    private boolean isEpsilonSuccessorOfDecision(Integer stateNumber) {
        StateWithContext lastDecisionState = getPrecedingDecisionState();
        ATNState lastState = getStateFromStateIndex(stateNumber);
        if (lastDecisionState == null) {
            return false;
        }
        return reachesStateByEpsilon(lastDecisionState.state, lastState);
    }

    private boolean reachesStateByEpsilon(ATNState fromState, ATNState toState) {
        if (fromState == toState) {
            return true;
        } else {
            for (Transition t : fromState.getTransitions()) {
                if (t.isEpsilon()) {
                    if (reachesStateByEpsilon(t.target, toState)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    private StateWithContext getPrecedingDecisionState() {
        return ((AutocompletionErrorStrategy) _errHandler).getLastDecisionState();
    }
}
