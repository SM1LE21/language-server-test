/* generated by template _lsp.features.completion.CompletionProvider*/

package de.monticore.lang.sd4development._lsp.features.completion;

import de.monticore.symboltable.IScope;
import de.monticore.lang.sd4development._lsp.features.completion.strategy.SD4DevelopmentDefaultCompletionStrategy;
import de.monticore.lang.sd4development._lsp.language_access.SD4DevelopmentLanguageAccess;
import de.monticore.lang.sd4development._parser.SD4DevelopmentParserInfo;
import de.mclsg.atn.StateWithContext;
import de.mclsg.lsp.document_management.DocumentInformation;
import de.mclsg.lsp.document_management.DocumentManager;
import de.mclsg.lsp.features.completion.CommonCompletionProvider;
import de.mclsg.lsp.features.completion.ExpectedToken;
import de.mclsg.lsp.features.completion.strategy.CompletionStrategy;
import de.mclsg.lsp.ISymbolUsageResolutionProvider;
import de.monticore.symboltable.ISymbol;
import org.eclipse.lsp4j.CompletionItem;
import de.mclsg.parser.MatchedToken;
import de.monticore.lang.sd4development._symboltable.ISD4DevelopmentArtifactScope;
import de.mclsg.atn.ATNUtilites;
import de.mclsg.lsp.CommonLanguageServer;

import java.util.*;
import java.util.regex.*;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.monticore.symbols.oosymbols._symboltable.FieldSymbol;
import de.monticore.symbols.oosymbols._symboltable.MethodSymbol;
import de.monticore.symbols.basicsymbols._symboltable.VariableSymbol;
import de.monticore.symbols.oosymbols._symboltable.OOTypeSymbol;
import de.monticore.symbols.basicsymbols._symboltable.DiagramSymbol;
import de.monticore.symbols.basicsymbols._symboltable.TypeVarSymbol;
import de.monticore.symbols.basicsymbols._symboltable.FunctionSymbol;
import de.monticore.symbols.basicsymbols._symboltable.TypeSymbol;

public class SD4DevelopmentCompletionProvider extends CommonCompletionProvider {
    private static final Logger logger = LoggerFactory.getLogger(SD4DevelopmentCompletionProvider.class);
    protected final SD4DevelopmentLanguageAccess languageAccess;
    protected SD4DevelopmentCompletionAntlrParser parser;
    protected ISymbolUsageResolutionProvider symbolUsageResolutionProvider;

    public SD4DevelopmentCompletionProvider(CommonLanguageServer languageServer, DocumentManager documentManager, SD4DevelopmentLanguageAccess languageAccess, ISymbolUsageResolutionProvider symbolUsageResolutionProvider) {
        super(languageServer, documentManager);

        this.languageAccess = languageAccess;
        this.symbolUsageResolutionProvider = symbolUsageResolutionProvider;
        completionStrategyManager.registerDefaultCompletionStrategy(new SD4DevelopmentDefaultCompletionStrategy(symbolUsageResolutionProvider, documentManager));

        registerNoSymbolNamesAtSymbolDef();
				registerSymbolRefCompletionStrategies();
				registerLocalKeywordCompletionStrategy();
    }

    public void registerSymbolRefCompletionStrategies(){
			completionStrategyManager.registerCompletionStrategy(new de.monticore.lang.sd4development._lsp.features.completion.strategy.referenced_symbol.VariableReferencedSymbolStrategy(symbolUsageResolutionProvider, documentManager));
    }

    public void registerNoSymbolNamesAtSymbolDef(){
      completionStrategyManager.registerCompletionStrategy(new CompletionStrategy(){
        public boolean matches(ExpectedToken expectedToken){
          return expectedToken.isSymbol && SD4DevelopmentParserInfo.stateDefinesName(expectedToken.parserState);
        }

        public List<? extends ISymbol> getSymbols(ExpectedToken token, DocumentInformation documentInformation){
          return new ArrayList<>();
        }
      });
    }

    @Override
    public List<CompletionItem> getParserCompletion(String input) {
        // TODO: common
				if(!input.isEmpty()){
					inputEndsWithWhitespace = input.substring(input.length() - 1).matches("\\s");
				}
        this.parser = languageAccess.getCompletionParser(input);
        parser.parse();

        this.lastToken = parser.getLastToken();
        this.firstStatesOfParserCompletion = Arrays.asList(parser.getFirstStatesOfParserCompletion());
        nameTokensMatchedWhileParsing = parser.getMatchedTokens().stream().filter(mt -> mt.isNameToken).collect(Collectors.toList());

        return getExpectedLiteralTokens(firstStatesOfParserCompletion)
                  .stream()
                  .flatMap(expectedToken -> completionStrategyManager.getCompletionStrategy(expectedToken).modifyParserCompletion(expectedToken).stream())
                  .distinct()
                  .map(CompletionItem::new)
                  .peek(ci -> ci.setKind(org.eclipse.lsp4j.CompletionItemKind.Keyword))
                  .collect(Collectors.toList());
    }

    @Override
    protected List<ExpectedToken> getExpectedTokens(StateWithContext stateWithContext) {
				List<ExpectedToken> res = new ArrayList<>(
						parser
								.getExpectedTokenVisitor()
                .getExpectedTokens()
								.stream()
								.peek(et -> et.setNameTokensMatchedBefore(
												(int) nameTokensMatchedWhileParsing.stream().filter(mt -> mt.context != null && mt.context.equals(et.context)).count()
								))
								.peek(et -> et.tokensMatchedBefore = nameTokensMatchedWhileParsing)
								.collect(Collectors.toList())
				);

				getContinuationToken().ifPresent(ct -> res.add(ct));
        return res;
    }

    @Override
    protected String getTokenName(int tokenIndex){
        return ATNUtilites.getTokenName(parser.getVocabulary(), tokenIndex);
    }
}
