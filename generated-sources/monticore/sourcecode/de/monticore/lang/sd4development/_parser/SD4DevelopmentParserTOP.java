/* generated from model SD4Development */
/* generated by template cd2java.Class*/

/* (c) https://github.com/MontiCore/monticore */

/* Hookpoint: ClassContent:addComment */

/* generated by template cd2java.Package*/
package de.monticore.lang.sd4development._parser;


/* generated by template cd2java.Imports*/

import java.util.*;
import java.util.function.*;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import de.se_rwth.commons.SourcePosition;



/* Hookpoint: ClassContent:Imports */



/* Hookpoint: ClassContent:Annotations */

 abstract  public  class SD4DevelopmentParserTOP extends de.monticore.antlr4.MCConcreteParser  {

/* Hookpoint: ClassContent:Elements */



    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 protected  SD4DevelopmentAntlrParser create (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.Create*/

  SD4DevelopmentAntlrLexer lexer = new SD4DevelopmentAntlrLexer(org.antlr.v4.runtime.CharStreams.fromFileName(fileName));
  org.antlr.v4.runtime.CommonTokenStream tokens = new org.antlr.v4.runtime.CommonTokenStream(lexer);
  SD4DevelopmentAntlrParser parser = new SD4DevelopmentAntlrParser(tokens);
  lexer.setMCParser(parser);
  lexer.removeErrorListeners();
  lexer.addErrorListener(new de.monticore.antlr4.MCErrorListener(parser));
  parser.setFilename(fileName);
  setError(false);
  return parser;
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 protected  SD4DevelopmentAntlrParser create (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.CreateReader*/

  SD4DevelopmentAntlrLexer lexer = new SD4DevelopmentAntlrLexer(org.antlr.v4.runtime.CharStreams.fromReader(reader));
  org.antlr.v4.runtime.CommonTokenStream tokens = new org.antlr.v4.runtime.CommonTokenStream(lexer);
  SD4DevelopmentAntlrParser parser = new SD4DevelopmentAntlrParser(tokens);
  lexer.setMCParser(parser);
  lexer.removeErrorListeners();
  lexer.addErrorListener(new de.monticore.antlr4.MCErrorListener(parser));
  parser.setFilename("StringReader");
  setError(false);
  return parser;
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDArtifact> parse (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.Parse*/

  return parseSDArtifact(fileName);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDArtifact> parse (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseReader*/

  return parseSDArtifact(reader);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDArtifact> parse_String (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseString*/

  return parse_StringSDArtifact(str);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDCall> parseSDCall (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sd4development._ast.ASTSDCall ast;
  ast = parser.sDCall().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDCall> parseSDCall (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sd4development._ast.ASTSDCall ast;
  ast = parser.sDCall().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDCall> parse_StringSDCall (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDCall(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDNew> parseSDNew (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sd4development._ast.ASTSDNew ast;
  ast = parser.sDNew().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDNew> parseSDNew (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sd4development._ast.ASTSDNew ast;
  ast = parser.sDNew().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDNew> parse_StringSDNew (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDNew(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDReturn> parseSDReturn (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sd4development._ast.ASTSDReturn ast;
  ast = parser.sDReturn().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDReturn> parseSDReturn (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sd4development._ast.ASTSDReturn ast;
  ast = parser.sDReturn().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDReturn> parse_StringSDReturn (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDReturn(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDThrow> parseSDThrow (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sd4development._ast.ASTSDThrow ast;
  ast = parser.sDThrow().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDThrow> parseSDThrow (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sd4development._ast.ASTSDThrow ast;
  ast = parser.sDThrow().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDThrow> parse_StringSDThrow (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDThrow(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDEndCall> parseSDEndCall (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sd4development._ast.ASTSDEndCall ast;
  ast = parser.sDEndCall().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDEndCall> parseSDEndCall (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sd4development._ast.ASTSDEndCall ast;
  ast = parser.sDEndCall().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDEndCall> parse_StringSDEndCall (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDEndCall(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDEndCallArrow> parseSDEndCallArrow (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sd4development._ast.ASTSDEndCallArrow ast;
  ast = parser.sDEndCallArrow().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDEndCallArrow> parseSDEndCallArrow (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sd4development._ast.ASTSDEndCallArrow ast;
  ast = parser.sDEndCallArrow().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDEndCallArrow> parse_StringSDEndCallArrow (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDEndCallArrow(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDIncompleteExpression> parseSDIncompleteExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sd4development._ast.ASTSDIncompleteExpression ast;
  ast = parser.sDIncompleteExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDIncompleteExpression> parseSDIncompleteExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sd4development._ast.ASTSDIncompleteExpression ast;
  ast = parser.sDIncompleteExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDIncompleteExpression> parse_StringSDIncompleteExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDIncompleteExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDClass> parseSDClass (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sd4development._ast.ASTSDClass ast;
  ast = parser.sDClass().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDClass> parseSDClass (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sd4development._ast.ASTSDClass ast;
  ast = parser.sDClass().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDClass> parse_StringSDClass (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDClass(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDCondition> parseSDCondition (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sd4development._ast.ASTSDCondition ast;
  ast = parser.sDCondition().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDCondition> parseSDCondition (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sd4development._ast.ASTSDCondition ast;
  ast = parser.sDCondition().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDCondition> parse_StringSDCondition (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDCondition(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDVariableDeclaration> parseSDVariableDeclaration (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sd4development._ast.ASTSDVariableDeclaration ast;
  ast = parser.sDVariableDeclaration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDVariableDeclaration> parseSDVariableDeclaration (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sd4development._ast.ASTSDVariableDeclaration ast;
  ast = parser.sDVariableDeclaration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sd4development._ast.ASTSDVariableDeclaration> parse_StringSDVariableDeclaration (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDVariableDeclaration(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDArtifact> parseSDArtifact (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDArtifact ast;
  ast = parser.sDArtifact().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDArtifact> parseSDArtifact (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDArtifact ast;
  ast = parser.sDArtifact().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDArtifact> parse_StringSDArtifact (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDArtifact(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSequenceDiagram> parseSequenceDiagram (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSequenceDiagram ast;
  ast = parser.sequenceDiagram().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSequenceDiagram> parseSequenceDiagram (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSequenceDiagram ast;
  ast = parser.sequenceDiagram().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSequenceDiagram> parse_StringSequenceDiagram (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSequenceDiagram(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDBody> parseSDBody (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDBody ast;
  ast = parser.sDBody().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDBody> parseSDBody (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDBody ast;
  ast = parser.sDBody().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDBody> parse_StringSDBody (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDBody(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDCompleteModifier> parseSDCompleteModifier (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDCompleteModifier ast;
  ast = parser.sDCompleteModifier().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDCompleteModifier> parseSDCompleteModifier (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDCompleteModifier ast;
  ast = parser.sDCompleteModifier().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDCompleteModifier> parse_StringSDCompleteModifier (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDCompleteModifier(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDFreeModifier> parseSDFreeModifier (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDFreeModifier ast;
  ast = parser.sDFreeModifier().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDFreeModifier> parseSDFreeModifier (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDFreeModifier ast;
  ast = parser.sDFreeModifier().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDFreeModifier> parse_StringSDFreeModifier (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDFreeModifier(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDInitialModifier> parseSDInitialModifier (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDInitialModifier ast;
  ast = parser.sDInitialModifier().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDInitialModifier> parseSDInitialModifier (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDInitialModifier ast;
  ast = parser.sDInitialModifier().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDInitialModifier> parse_StringSDInitialModifier (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDInitialModifier(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDVisibleModifier> parseSDVisibleModifier (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDVisibleModifier ast;
  ast = parser.sDVisibleModifier().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDVisibleModifier> parseSDVisibleModifier (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDVisibleModifier ast;
  ast = parser.sDVisibleModifier().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDVisibleModifier> parse_StringSDVisibleModifier (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDVisibleModifier(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDObject> parseSDObject (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDObject ast;
  ast = parser.sDObject().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDObject> parseSDObject (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDObject ast;
  ast = parser.sDObject().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDObject> parse_StringSDObject (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDObject(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDObjectSource> parseSDObjectSource (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDObjectSource ast;
  ast = parser.sDObjectSource().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDObjectSource> parseSDObjectSource (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDObjectSource ast;
  ast = parser.sDObjectSource().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDObjectSource> parse_StringSDObjectSource (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDObjectSource(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDObjectTarget> parseSDObjectTarget (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDObjectTarget ast;
  ast = parser.sDObjectTarget().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDObjectTarget> parseSDObjectTarget (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDObjectTarget ast;
  ast = parser.sDObjectTarget().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDObjectTarget> parse_StringSDObjectTarget (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDObjectTarget(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDSendMessage> parseSDSendMessage (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDSendMessage ast;
  ast = parser.sDSendMessage().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDSendMessage> parseSDSendMessage (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDSendMessage ast;
  ast = parser.sDSendMessage().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDSendMessage> parse_StringSDSendMessage (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDSendMessage(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDActivityBar> parseSDActivityBar (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDActivityBar ast;
  ast = parser.sDActivityBar().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDActivityBar> parseSDActivityBar (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDActivityBar ast;
  ast = parser.sDActivityBar().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDActivityBar> parse_StringSDActivityBar (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDActivityBar(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDModifier> parseSDModifier (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDModifier ast;
  ast = parser.sDModifier().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDModifier> parseSDModifier (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDModifier ast;
  ast = parser.sDModifier().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDModifier> parse_StringSDModifier (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDModifier(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDElement> parseSDElement (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDElement ast;
  ast = parser.sDElement().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDElement> parseSDElement (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDElement ast;
  ast = parser.sDElement().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDElement> parse_StringSDElement (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDElement(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDInteraction> parseSDInteraction (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDInteraction ast;
  ast = parser.sDInteraction().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDInteraction> parseSDInteraction (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDInteraction ast;
  ast = parser.sDInteraction().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDInteraction> parse_StringSDInteraction (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDInteraction(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDSource> parseSDSource (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDSource ast;
  ast = parser.sDSource().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDSource> parseSDSource (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDSource ast;
  ast = parser.sDSource().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDSource> parse_StringSDSource (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDSource(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDTarget> parseSDTarget (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDTarget ast;
  ast = parser.sDTarget().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDTarget> parseSDTarget (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDTarget ast;
  ast = parser.sDTarget().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDTarget> parse_StringSDTarget (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDTarget(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDAction> parseSDAction (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.lang.sdbasis._ast.ASTSDAction ast;
  ast = parser.sDAction().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDAction> parseSDAction (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.lang.sdbasis._ast.ASTSDAction ast;
  ast = parser.sDAction().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.lang.sdbasis._ast.ASTSDAction> parse_StringSDAction (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSDAction(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName> parseMCQualifiedName (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName ast;
  ast = parser.mCQualifiedName().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName> parseMCQualifiedName (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName ast;
  ast = parser.mCQualifiedName().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName> parse_StringMCQualifiedName (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCQualifiedName(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPackageDeclaration> parseMCPackageDeclaration (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCPackageDeclaration ast;
  ast = parser.mCPackageDeclaration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPackageDeclaration> parseMCPackageDeclaration (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCPackageDeclaration ast;
  ast = parser.mCPackageDeclaration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPackageDeclaration> parse_StringMCPackageDeclaration (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCPackageDeclaration(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCImportStatement> parseMCImportStatement (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCImportStatement ast;
  ast = parser.mCImportStatement().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCImportStatement> parseMCImportStatement (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCImportStatement ast;
  ast = parser.mCImportStatement().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCImportStatement> parse_StringMCImportStatement (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCImportStatement(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType> parseMCPrimitiveType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType ast;
  ast = parser.mCPrimitiveType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType> parseMCPrimitiveType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType ast;
  ast = parser.mCPrimitiveType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType> parse_StringMCPrimitiveType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCPrimitiveType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType> parseMCQualifiedType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType ast;
  ast = parser.mCQualifiedType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType> parseMCQualifiedType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType ast;
  ast = parser.mCQualifiedType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType> parse_StringMCQualifiedType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCQualifiedType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCReturnType> parseMCReturnType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCReturnType ast;
  ast = parser.mCReturnType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCReturnType> parseMCReturnType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCReturnType ast;
  ast = parser.mCReturnType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCReturnType> parse_StringMCReturnType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCReturnType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCVoidType> parseMCVoidType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCVoidType ast;
  ast = parser.mCVoidType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCVoidType> parseMCVoidType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCVoidType ast;
  ast = parser.mCVoidType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCVoidType> parse_StringMCVoidType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCVoidType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCType> parseMCType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCType ast;
  ast = parser.mCType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCType> parseMCType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCType ast;
  ast = parser.mCType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCType> parse_StringMCType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCObjectType> parseMCObjectType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.types.mcbasictypes._ast.ASTMCObjectType ast;
  ast = parser.mCObjectType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCObjectType> parseMCObjectType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.types.mcbasictypes._ast.ASTMCObjectType ast;
  ast = parser.mCObjectType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.types.mcbasictypes._ast.ASTMCObjectType> parse_StringMCObjectType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMCObjectType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTDiagram> parseDiagram (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.symbols.basicsymbols._ast.ASTDiagram ast;
  ast = parser.diagram().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTDiagram> parseDiagram (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.symbols.basicsymbols._ast.ASTDiagram ast;
  ast = parser.diagram().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTDiagram> parse_StringDiagram (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseDiagram(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTType> parseType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.symbols.basicsymbols._ast.ASTType ast;
  ast = parser.type().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTType> parseType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.symbols.basicsymbols._ast.ASTType ast;
  ast = parser.type().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTType> parse_StringType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTTypeVar> parseTypeVar (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.symbols.basicsymbols._ast.ASTTypeVar ast;
  ast = parser.typeVar().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTTypeVar> parseTypeVar (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.symbols.basicsymbols._ast.ASTTypeVar ast;
  ast = parser.typeVar().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTTypeVar> parse_StringTypeVar (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseTypeVar(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTVariable> parseVariable (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.symbols.basicsymbols._ast.ASTVariable ast;
  ast = parser.variable().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTVariable> parseVariable (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.symbols.basicsymbols._ast.ASTVariable ast;
  ast = parser.variable().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTVariable> parse_StringVariable (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseVariable(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTFunction> parseFunction (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.symbols.basicsymbols._ast.ASTFunction ast;
  ast = parser.function().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTFunction> parseFunction (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.symbols.basicsymbols._ast.ASTFunction ast;
  ast = parser.function().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.basicsymbols._ast.ASTFunction> parse_StringFunction (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseFunction(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTNameExpression> parseNameExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.expressions.expressionsbasis._ast.ASTNameExpression ast;
  ast = parser.nameExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTNameExpression> parseNameExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.expressions.expressionsbasis._ast.ASTNameExpression ast;
  ast = parser.nameExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTNameExpression> parse_StringNameExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseNameExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTLiteralExpression> parseLiteralExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.expressions.expressionsbasis._ast.ASTLiteralExpression ast;
  ast = parser.literalExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTLiteralExpression> parseLiteralExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.expressions.expressionsbasis._ast.ASTLiteralExpression ast;
  ast = parser.literalExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTLiteralExpression> parse_StringLiteralExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseLiteralExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTArguments> parseArguments (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.expressions.expressionsbasis._ast.ASTArguments ast;
  ast = parser.arguments().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTArguments> parseArguments (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.expressions.expressionsbasis._ast.ASTArguments ast;
  ast = parser.arguments().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTArguments> parse_StringArguments (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseArguments(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTExpression> parseExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.expressions.expressionsbasis._ast.ASTExpression ast;
  ast = parser.expression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTExpression> parseExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.expressions.expressionsbasis._ast.ASTExpression ast;
  ast = parser.expression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.expressionsbasis._ast.ASTExpression> parse_StringExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcliteralsbasis._ast.ASTLiteral> parseLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mcliteralsbasis._ast.ASTLiteral ast;
  ast = parser.literal().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcliteralsbasis._ast.ASTLiteral> parseLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mcliteralsbasis._ast.ASTLiteral ast;
  ast = parser.literal().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mcliteralsbasis._ast.ASTLiteral> parse_StringLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.umlstereotype._ast.ASTStereotype> parseStereotype (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.umlstereotype._ast.ASTStereotype ast;
  ast = parser.stereotype().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.umlstereotype._ast.ASTStereotype> parseStereotype (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.umlstereotype._ast.ASTStereotype ast;
  ast = parser.stereotype().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.umlstereotype._ast.ASTStereotype> parse_StringStereotype (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseStereotype(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.umlstereotype._ast.ASTStereoValue> parseStereoValue (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.umlstereotype._ast.ASTStereoValue ast;
  ast = parser.stereoValue().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.umlstereotype._ast.ASTStereoValue> parseStereoValue (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.umlstereotype._ast.ASTStereoValue ast;
  ast = parser.stereoValue().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.umlstereotype._ast.ASTStereoValue> parse_StringStereoValue (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseStereoValue(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNullLiteral> parseNullLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTNullLiteral ast;
  ast = parser.nullLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNullLiteral> parseNullLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTNullLiteral ast;
  ast = parser.nullLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNullLiteral> parse_StringNullLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseNullLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral> parseBooleanLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral ast;
  ast = parser.booleanLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral> parseBooleanLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral ast;
  ast = parser.booleanLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral> parse_StringBooleanLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBooleanLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTCharLiteral> parseCharLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTCharLiteral ast;
  ast = parser.charLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTCharLiteral> parseCharLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTCharLiteral ast;
  ast = parser.charLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTCharLiteral> parse_StringCharLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseCharLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTStringLiteral> parseStringLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTStringLiteral ast;
  ast = parser.stringLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTStringLiteral> parseStringLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTStringLiteral ast;
  ast = parser.stringLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTStringLiteral> parse_StringStringLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseStringLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNatLiteral> parseNatLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTNatLiteral ast;
  ast = parser.natLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNatLiteral> parseNatLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTNatLiteral ast;
  ast = parser.natLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNatLiteral> parse_StringNatLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseNatLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral> parseSignedNatLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral ast;
  ast = parser.signedNatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral> parseSignedNatLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral ast;
  ast = parser.signedNatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral> parse_StringSignedNatLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedNatLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral> parseBasicLongLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral ast;
  ast = parser.basicLongLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral> parseBasicLongLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral ast;
  ast = parser.basicLongLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral> parse_StringBasicLongLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBasicLongLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral> parseSignedBasicLongLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral ast;
  ast = parser.signedBasicLongLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral> parseSignedBasicLongLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral ast;
  ast = parser.signedBasicLongLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral> parse_StringSignedBasicLongLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedBasicLongLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral> parseBasicFloatLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral ast;
  ast = parser.basicFloatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral> parseBasicFloatLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral ast;
  ast = parser.basicFloatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral> parse_StringBasicFloatLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBasicFloatLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral> parseSignedBasicFloatLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral ast;
  ast = parser.signedBasicFloatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral> parseSignedBasicFloatLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral ast;
  ast = parser.signedBasicFloatLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral> parse_StringSignedBasicFloatLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedBasicFloatLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral> parseBasicDoubleLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral ast;
  ast = parser.basicDoubleLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral> parseBasicDoubleLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral ast;
  ast = parser.basicDoubleLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral> parse_StringBasicDoubleLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBasicDoubleLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral> parseSignedBasicDoubleLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral ast;
  ast = parser.signedBasicDoubleLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral> parseSignedBasicDoubleLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral ast;
  ast = parser.signedBasicDoubleLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral> parse_StringSignedBasicDoubleLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedBasicDoubleLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral> parseSignedLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral ast;
  ast = parser.signedLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral> parseSignedLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral ast;
  ast = parser.signedLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral> parse_StringSignedLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral> parseNumericLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral ast;
  ast = parser.numericLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral> parseNumericLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral ast;
  ast = parser.numericLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral> parse_StringNumericLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseNumericLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral> parseSignedNumericLiteral (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral ast;
  ast = parser.signedNumericLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral> parseSignedNumericLiteral (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral ast;
  ast = parser.signedNumericLiteral().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral> parse_StringSignedNumericLiteral (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseSignedNumericLiteral(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTPlusPrefixExpression> parsePlusPrefixExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.expressions.commonexpressions._ast.ASTPlusPrefixExpression ast;
  ast = parser.plusPrefixExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTPlusPrefixExpression> parsePlusPrefixExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.expressions.commonexpressions._ast.ASTPlusPrefixExpression ast;
  ast = parser.plusPrefixExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTPlusPrefixExpression> parse_StringPlusPrefixExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parsePlusPrefixExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTMinusPrefixExpression> parseMinusPrefixExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.expressions.commonexpressions._ast.ASTMinusPrefixExpression ast;
  ast = parser.minusPrefixExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTMinusPrefixExpression> parseMinusPrefixExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.expressions.commonexpressions._ast.ASTMinusPrefixExpression ast;
  ast = parser.minusPrefixExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTMinusPrefixExpression> parse_StringMinusPrefixExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMinusPrefixExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTBooleanNotExpression> parseBooleanNotExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.expressions.commonexpressions._ast.ASTBooleanNotExpression ast;
  ast = parser.booleanNotExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTBooleanNotExpression> parseBooleanNotExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.expressions.commonexpressions._ast.ASTBooleanNotExpression ast;
  ast = parser.booleanNotExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTBooleanNotExpression> parse_StringBooleanNotExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBooleanNotExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTLogicalNotExpression> parseLogicalNotExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.expressions.commonexpressions._ast.ASTLogicalNotExpression ast;
  ast = parser.logicalNotExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTLogicalNotExpression> parseLogicalNotExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.expressions.commonexpressions._ast.ASTLogicalNotExpression ast;
  ast = parser.logicalNotExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTLogicalNotExpression> parse_StringLogicalNotExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseLogicalNotExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTBracketExpression> parseBracketExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.expressions.commonexpressions._ast.ASTBracketExpression ast;
  ast = parser.bracketExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTBracketExpression> parseBracketExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.expressions.commonexpressions._ast.ASTBracketExpression ast;
  ast = parser.bracketExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTBracketExpression> parse_StringBracketExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseBracketExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTInfixExpression> parseInfixExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.expressions.commonexpressions._ast.ASTInfixExpression ast;
  ast = parser.infixExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTInfixExpression> parseInfixExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.expressions.commonexpressions._ast.ASTInfixExpression ast;
  ast = parser.infixExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.expressions.commonexpressions._ast.ASTInfixExpression> parse_StringInfixExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseInfixExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTOCLVariableDeclaration> parseOCLVariableDeclaration (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTOCLVariableDeclaration ast;
  ast = parser.oCLVariableDeclaration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTOCLVariableDeclaration> parseOCLVariableDeclaration (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTOCLVariableDeclaration ast;
  ast = parser.oCLVariableDeclaration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTOCLVariableDeclaration> parse_StringOCLVariableDeclaration (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseOCLVariableDeclaration(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTTypeIfExpression> parseTypeIfExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTTypeIfExpression ast;
  ast = parser.typeIfExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTTypeIfExpression> parseTypeIfExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTTypeIfExpression ast;
  ast = parser.typeIfExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTTypeIfExpression> parse_StringTypeIfExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseTypeIfExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTTypeIfThenExpression> parseTypeIfThenExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTTypeIfThenExpression ast;
  ast = parser.typeIfThenExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTTypeIfThenExpression> parseTypeIfThenExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTTypeIfThenExpression ast;
  ast = parser.typeIfThenExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTTypeIfThenExpression> parse_StringTypeIfThenExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseTypeIfThenExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTIfThenElseExpression> parseIfThenElseExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTIfThenElseExpression ast;
  ast = parser.ifThenElseExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTIfThenElseExpression> parseIfThenElseExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTIfThenElseExpression ast;
  ast = parser.ifThenElseExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTIfThenElseExpression> parse_StringIfThenElseExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseIfThenElseExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTForallExpression> parseForallExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTForallExpression ast;
  ast = parser.forallExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTForallExpression> parseForallExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTForallExpression ast;
  ast = parser.forallExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTForallExpression> parse_StringForallExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseForallExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTExistsExpression> parseExistsExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTExistsExpression ast;
  ast = parser.existsExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTExistsExpression> parseExistsExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTExistsExpression ast;
  ast = parser.existsExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTExistsExpression> parse_StringExistsExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseExistsExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTAnyExpression> parseAnyExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTAnyExpression ast;
  ast = parser.anyExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTAnyExpression> parseAnyExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTAnyExpression ast;
  ast = parser.anyExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTAnyExpression> parse_StringAnyExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseAnyExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTLetinExpression> parseLetinExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTLetinExpression ast;
  ast = parser.letinExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTLetinExpression> parseLetinExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTLetinExpression ast;
  ast = parser.letinExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTLetinExpression> parse_StringLetinExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseLetinExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTIterateExpression> parseIterateExpression (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTIterateExpression ast;
  ast = parser.iterateExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTIterateExpression> parseIterateExpression (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTIterateExpression ast;
  ast = parser.iterateExpression().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTIterateExpression> parse_StringIterateExpression (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseIterateExpression(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTInDeclaration> parseInDeclaration (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTInDeclaration ast;
  ast = parser.inDeclaration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTInDeclaration> parseInDeclaration (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTInDeclaration ast;
  ast = parser.inDeclaration().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTInDeclaration> parse_StringInDeclaration (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseInDeclaration(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTInDeclarationVariable> parseInDeclarationVariable (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.ocl.oclexpressions._ast.ASTInDeclarationVariable ast;
  ast = parser.inDeclarationVariable().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTInDeclarationVariable> parseInDeclarationVariable (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.ocl.oclexpressions._ast.ASTInDeclarationVariable ast;
  ast = parser.inDeclarationVariable().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.ocl.oclexpressions._ast.ASTInDeclarationVariable> parse_StringInDeclarationVariable (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseInDeclarationVariable(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.oosymbols._ast.ASTOOType> parseOOType (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.symbols.oosymbols._ast.ASTOOType ast;
  ast = parser.oOType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.oosymbols._ast.ASTOOType> parseOOType (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.symbols.oosymbols._ast.ASTOOType ast;
  ast = parser.oOType().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.oosymbols._ast.ASTOOType> parse_StringOOType (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseOOType(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.oosymbols._ast.ASTField> parseField (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.symbols.oosymbols._ast.ASTField ast;
  ast = parser.field().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.oosymbols._ast.ASTField> parseField (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.symbols.oosymbols._ast.ASTField ast;
  ast = parser.field().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.oosymbols._ast.ASTField> parse_StringField (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseField(new java.io.StringReader(str));
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.oosymbols._ast.ASTMethod> parseMethod (String fileName)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRule*/

  SD4DevelopmentAntlrParser parser = create(fileName);
  de.monticore.symbols.oosymbols._ast.ASTMethod ast;
  ast = parser.method().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.oosymbols._ast.ASTMethod> parseMethod (java.io.Reader reader)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleReader*/

  SD4DevelopmentAntlrParser parser = create(reader);
  de.monticore.symbols.oosymbols._ast.ASTMethod ast;
  ast = parser.method().ret;
  if (parser.hasErrors()) {
    setError(true);
    return Optional.empty();
  }
  // Check for EOF
  org.antlr.v4.runtime.Token currentToken = parser.getCurrentToken();
  if (currentToken != null && currentToken.getType() != -1) {
    setError(true);
    Log.error("Expected EOF but found token " + currentToken, parser.computeStartPosition(currentToken));
    return Optional.empty();
  }
  return Optional.of(ast);
}

    /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symbols.oosymbols._ast.ASTMethod> parse_StringMethod (String str)
 throws java.io.IOException
 {
    /* generated by template _parser.ParseRuleString*/

  return parseMethod(new java.io.StringReader(str));
}


}


