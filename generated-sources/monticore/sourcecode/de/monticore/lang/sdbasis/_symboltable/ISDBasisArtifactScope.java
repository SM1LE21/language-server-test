/* generated from model SDBasis */
/* generated by template cd2java.Interface*/

/* (c) https://github.com/MontiCore/monticore */

/* Hookpoint: InterfaceContent:addComment */

/* generated by template cd2java.Package*/
package de.monticore.lang.sdbasis._symboltable;


/* generated by template cd2java.Imports*/

import java.util.*;
import java.util.function.*;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import de.se_rwth.commons.SourcePosition;

import de.monticore.symboltable.*;


/* Hookpoint: InterfaceContent:Imports */



/* Hookpoint: InterfaceContent:Annotations */

 public  interface ISDBasisArtifactScope extends de.monticore.types.mcbasictypes._symboltable.IMCBasicTypesArtifactScope,de.monticore.symbols.basicsymbols._symboltable.IBasicSymbolsArtifactScope,de.monticore.expressions.expressionsbasis._symboltable.IExpressionsBasisArtifactScope,de.monticore.umlstereotype._symboltable.IUMLStereotypeArtifactScope,de.monticore.lang.sdbasis._symboltable.ISDBasisScope  { 
/* Hookpoint: InterfaceContent:Elements */


  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean containsImports (Object element)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().contains(element);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean containsAllImports (Collection<?> collection)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().containsAll(collection);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean isEmptyImports ()

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().isEmpty();

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Iterator<de.monticore.symboltable.ImportStatement> iteratorImports ()

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().iterator();

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  int sizeImports ()

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().size();

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  de.monticore.symboltable.ImportStatement[] toArrayImports (de.monticore.symboltable.ImportStatement[] array)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().toArray(array);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Object[] toArrayImports ()

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().toArray();

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Spliterator<de.monticore.symboltable.ImportStatement> spliteratorImports ()

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().spliterator();

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Stream<de.monticore.symboltable.ImportStatement> streamImports ()

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().stream();

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Stream<de.monticore.symboltable.ImportStatement> parallelStreamImports ()

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().parallelStream();

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  de.monticore.symboltable.ImportStatement getImports (int index)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().get(index);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  int indexOfImports (Object element)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().indexOf(element);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  int lastIndexOfImports (Object element)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().lastIndexOf(element);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean equalsImports (Object o)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().equals(o);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  int hashCodeImports ()

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().hashCode();

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  ListIterator<de.monticore.symboltable.ImportStatement> listIteratorImports ()

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().listIterator();

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  ListIterator<de.monticore.symboltable.ImportStatement> listIteratorImports (int index)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().listIterator(index);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  List<de.monticore.symboltable.ImportStatement> subListImports (int start,int end)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().subList(start, end);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  void clearImports ()

 {
    /* generated by template methods.MethodDelegate*/

this.getImportsList().clear();

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean addImports (de.monticore.symboltable.ImportStatement element)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().add(element);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean addAllImports (Collection<? extends de.monticore.symboltable.ImportStatement> collection)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().addAll(collection);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean removeImports (Object element)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().remove(element);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean removeAllImports (Collection<?> collection)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().removeAll(collection);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean retainAllImports (Collection<?> collection)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().retainAll(collection);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean removeIfImports (Predicate<? super de.monticore.symboltable.ImportStatement> filter)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().removeIf(filter);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  void forEachImports (Consumer<? super de.monticore.symboltable.ImportStatement> action)

 {
    /* generated by template methods.MethodDelegate*/

this.getImportsList().forEach(action);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  void addImports (int index,de.monticore.symboltable.ImportStatement element)

 {
    /* generated by template methods.MethodDelegate*/

this.getImportsList().add(index, element);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean addAllImports (int index,Collection<? extends de.monticore.symboltable.ImportStatement> collection)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().addAll(index, collection);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  de.monticore.symboltable.ImportStatement removeImports (int index)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().remove(index);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  de.monticore.symboltable.ImportStatement setImports (int index,de.monticore.symboltable.ImportStatement element)

 {
    /* generated by template methods.MethodDelegate*/

return this.getImportsList().set(index, element);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  void replaceAllImports (UnaryOperator<de.monticore.symboltable.ImportStatement> operator)

 {
    /* generated by template methods.MethodDelegate*/

this.getImportsList().replaceAll(operator);

}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  void sortImports (Comparator<? super de.monticore.symboltable.ImportStatement> comparator)

 {
    /* generated by template methods.MethodDelegate*/

this.getImportsList().sort(comparator);

}

  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  List<de.monticore.symboltable.ImportStatement> getImportsList ()

;
  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  void setImportsList (List<de.monticore.symboltable.ImportStatement> imports)

;
  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  Optional<de.monticore.symboltable.ISymbol> getTopLevelSymbol ()

 {
    /* generated by template _symboltable.iartifactscope.GetTopLevelSymbol*/

  List<de.monticore.symboltable.ISymbol> topSymbolList = new ArrayList<>();
    topSymbolList.addAll(getDiagramSymbols().values());
    topSymbolList.addAll(getTypeSymbols().values());
    topSymbolList.addAll(getTypeVarSymbols().values());
    topSymbolList.addAll(getVariableSymbols().values());
    topSymbolList.addAll(getFunctionSymbols().values());
  if (topSymbolList.size() == 1) {
    return Optional.of(topSymbolList.get(0));
  }
  // there is no top level symbol, if more than one symbol exists.
  return Optional.empty();
}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  boolean checkIfContinueAsSubScope (String symbolName)

 {
    /* generated by template _symboltable.iartifactscope.CheckIfContinueAsSubScope*/
  if (this.isExportingSymbols()) {
    final String symbolQualifier = de.se_rwth.commons.Names.getQualifier(symbolName);

    final List<String> symbolQualifierParts = de.se_rwth.commons.Splitters.DOT.splitToList(symbolQualifier);
    final List<String> packageParts = de.se_rwth.commons.Splitters.DOT.splitToList(getPackageName());

    boolean symbolNameStartsWithPackage = true;

    if (getPackageName().isEmpty()) {
      // symbol qualifier always contains default package (i.e., empty string)
      symbolNameStartsWithPackage = true;
    } else if (symbolQualifierParts.size() >= packageParts.size()) {
      for (int i = 0; i < packageParts.size(); i++) {
        if (!packageParts.get(i).equals(symbolQualifierParts.get(i))) {
          symbolNameStartsWithPackage = false;
          break;
        }
      }
    } else {
      symbolNameStartsWithPackage = false;
    }
      return symbolNameStartsWithPackage;
  }
  return false;
}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  List<String> getRemainingNameForResolveDown (String symbolName)

 {
    /* generated by template _symboltable.iartifactscope.GetRemainingNameForResolveDown*/
  List<String> remainingSymbolNames = new ArrayList<>();
  String packageAS = this.getPackageName();
  if(symbolName.startsWith(packageAS)){
    if(!packageAS.equals("")){
      symbolName = symbolName.substring(packageAS.length()+1);
    }
    String asName = this.getName() + ".";
    remainingSymbolNames.add(symbolName);
    if(symbolName.startsWith(asName)){
      symbolName = symbolName.substring(asName.length());
      remainingSymbolNames.add(symbolName);
    }
  }

  return remainingSymbolNames;
}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  String getFullName ()

 {
    /* generated by template _symboltable.iartifactscope.GetFullName*/
  String packageName = this.getPackageName();
  if(this.isPresentName()){
    if(packageName.isEmpty()){
      return this.getName();
    }else{
      return packageName + "." + this.getName();
    }
  }else{
   return packageName;
  }
}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  List<de.monticore.symbols.basicsymbols._symboltable.DiagramSymbol> continueDiagramWithEnclosingScope (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.symbols.basicsymbols._symboltable.DiagramSymbol> predicate)

 {
    /* generated by template _symboltable.iartifactscope.ContinueWithEnclosingScope4ArtifactScope*/

  final Set<de.monticore.symbols.basicsymbols._symboltable.DiagramSymbol> result = new HashSet<>();

if (checkIfContinueWithEnclosingScope(foundSymbols) && getEnclosingScope() != null) {
if (!(getEnclosingScope() instanceof IGlobalScope)) {
      Log.warn("0xA1139 The artifact scope " + (isPresentName() ? getName() : "") + " should have a global scope as enclosing scope or no "
              + "enclosing scope at all.");
      }
    foundSymbols = foundSymbols | result.size() > 0;
    final Set<String> potentialQualifiedNames = calculateQualifiedNames(name, getPackageName(), getImportsList());

    for (final String potentialQualifiedName : potentialQualifiedNames) {
  final List<de.monticore.symbols.basicsymbols._symboltable.DiagramSymbol> resolvedFromEnclosing = getEnclosingScope().resolveDiagramMany(foundSymbols,
  potentialQualifiedName, modifier, predicate);
      foundSymbols = foundSymbols | resolvedFromEnclosing.size() > 0;
      result.addAll(resolvedFromEnclosing);
    }
  }
  return new ArrayList(result);
}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  List<de.monticore.symbols.basicsymbols._symboltable.TypeSymbol> continueTypeWithEnclosingScope (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.symbols.basicsymbols._symboltable.TypeSymbol> predicate)

 {
    /* generated by template _symboltable.iartifactscope.ContinueWithEnclosingScope4ArtifactScope*/

  final Set<de.monticore.symbols.basicsymbols._symboltable.TypeSymbol> result = new HashSet<>();

if (checkIfContinueWithEnclosingScope(foundSymbols) && getEnclosingScope() != null) {
if (!(getEnclosingScope() instanceof IGlobalScope)) {
      Log.warn("0xA1139 The artifact scope " + (isPresentName() ? getName() : "") + " should have a global scope as enclosing scope or no "
              + "enclosing scope at all.");
      }
    foundSymbols = foundSymbols | result.size() > 0;
    final Set<String> potentialQualifiedNames = calculateQualifiedNames(name, getPackageName(), getImportsList());

    for (final String potentialQualifiedName : potentialQualifiedNames) {
  final List<de.monticore.symbols.basicsymbols._symboltable.TypeSymbol> resolvedFromEnclosing = getEnclosingScope().resolveTypeMany(foundSymbols,
  potentialQualifiedName, modifier, predicate);
      foundSymbols = foundSymbols | resolvedFromEnclosing.size() > 0;
      result.addAll(resolvedFromEnclosing);
    }
  }
  return new ArrayList(result);
}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  List<de.monticore.symbols.basicsymbols._symboltable.TypeVarSymbol> continueTypeVarWithEnclosingScope (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.symbols.basicsymbols._symboltable.TypeVarSymbol> predicate)

 {
    /* generated by template _symboltable.iartifactscope.ContinueWithEnclosingScope4ArtifactScope*/

  final Set<de.monticore.symbols.basicsymbols._symboltable.TypeVarSymbol> result = new HashSet<>();

if (checkIfContinueWithEnclosingScope(foundSymbols) && getEnclosingScope() != null) {
if (!(getEnclosingScope() instanceof IGlobalScope)) {
      Log.warn("0xA1139 The artifact scope " + (isPresentName() ? getName() : "") + " should have a global scope as enclosing scope or no "
              + "enclosing scope at all.");
      }
    foundSymbols = foundSymbols | result.size() > 0;
    final Set<String> potentialQualifiedNames = calculateQualifiedNames(name, getPackageName(), getImportsList());

    for (final String potentialQualifiedName : potentialQualifiedNames) {
  final List<de.monticore.symbols.basicsymbols._symboltable.TypeVarSymbol> resolvedFromEnclosing = getEnclosingScope().resolveTypeVarMany(foundSymbols,
  potentialQualifiedName, modifier, predicate);
      foundSymbols = foundSymbols | resolvedFromEnclosing.size() > 0;
      result.addAll(resolvedFromEnclosing);
    }
  }
  return new ArrayList(result);
}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  List<de.monticore.symbols.basicsymbols._symboltable.VariableSymbol> continueVariableWithEnclosingScope (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.symbols.basicsymbols._symboltable.VariableSymbol> predicate)

 {
    /* generated by template _symboltable.iartifactscope.ContinueWithEnclosingScope4ArtifactScope*/

  final Set<de.monticore.symbols.basicsymbols._symboltable.VariableSymbol> result = new HashSet<>();

if (checkIfContinueWithEnclosingScope(foundSymbols) && getEnclosingScope() != null) {
if (!(getEnclosingScope() instanceof IGlobalScope)) {
      Log.warn("0xA1139 The artifact scope " + (isPresentName() ? getName() : "") + " should have a global scope as enclosing scope or no "
              + "enclosing scope at all.");
      }
    foundSymbols = foundSymbols | result.size() > 0;
    final Set<String> potentialQualifiedNames = calculateQualifiedNames(name, getPackageName(), getImportsList());

    for (final String potentialQualifiedName : potentialQualifiedNames) {
  final List<de.monticore.symbols.basicsymbols._symboltable.VariableSymbol> resolvedFromEnclosing = getEnclosingScope().resolveVariableMany(foundSymbols,
  potentialQualifiedName, modifier, predicate);
      foundSymbols = foundSymbols | resolvedFromEnclosing.size() > 0;
      result.addAll(resolvedFromEnclosing);
    }
  }
  return new ArrayList(result);
}

  default /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 public  List<de.monticore.symbols.basicsymbols._symboltable.FunctionSymbol> continueFunctionWithEnclosingScope (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.symbols.basicsymbols._symboltable.FunctionSymbol> predicate)

 {
    /* generated by template _symboltable.iartifactscope.ContinueWithEnclosingScope4ArtifactScope*/

  final Set<de.monticore.symbols.basicsymbols._symboltable.FunctionSymbol> result = new HashSet<>();

if (checkIfContinueWithEnclosingScope(foundSymbols) && getEnclosingScope() != null) {
if (!(getEnclosingScope() instanceof IGlobalScope)) {
      Log.warn("0xA1139 The artifact scope " + (isPresentName() ? getName() : "") + " should have a global scope as enclosing scope or no "
              + "enclosing scope at all.");
      }
    foundSymbols = foundSymbols | result.size() > 0;
    final Set<String> potentialQualifiedNames = calculateQualifiedNames(name, getPackageName(), getImportsList());

    for (final String potentialQualifiedName : potentialQualifiedNames) {
  final List<de.monticore.symbols.basicsymbols._symboltable.FunctionSymbol> resolvedFromEnclosing = getEnclosingScope().resolveFunctionMany(foundSymbols,
  potentialQualifiedName, modifier, predicate);
      foundSymbols = foundSymbols | resolvedFromEnclosing.size() > 0;
      result.addAll(resolvedFromEnclosing);
    }
  }
  return new ArrayList(result);
}

  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  void accept (de.monticore.lang.sdbasis._visitor.SDBasisTraverser visitor)

;
  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  void accept (de.monticore.types.mcbasictypes._visitor.MCBasicTypesTraverser visitor)

;
  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  void accept (de.monticore.symbols.basicsymbols._visitor.BasicSymbolsTraverser visitor)

;
  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  void accept (de.monticore.expressions.expressionsbasis._visitor.ExpressionsBasisTraverser visitor)

;
  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  void accept (de.monticore.umlstereotype._visitor.UMLStereotypeTraverser visitor)

;
  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  void accept (de.monticore.mcbasics._visitor.MCBasicsTraverser visitor)

;
  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  void accept (de.monticore.literals.mcliteralsbasis._visitor.MCLiteralsBasisTraverser visitor)

;
  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  void accept (de.monticore.literals.mccommonliterals._visitor.MCCommonLiteralsTraverser visitor)

;
  /* generated by template cd2java.Method*/

/* Hookpoint: MethodContent:Annotations */
 abstract  public  void accept (de.monticore.visitor.ITraverser visitor)

;
}
