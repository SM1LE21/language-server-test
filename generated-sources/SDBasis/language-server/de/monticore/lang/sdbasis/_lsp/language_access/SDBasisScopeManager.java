/* generated by template _lsp.language_access.ScopeManager*/

package de.monticore.lang.sdbasis._lsp.language_access;

import de.monticore.lang.sdbasis._ast.ASTSDArtifact;
import de.monticore.lang.sdbasis._lsp.SDBasisLspAntlrParser;
import de.monticore.lang.sdbasis._lsp.features.completion.SDBasisCompletionAntlrParser;
import de.monticore.lang.sdbasis._parser.SDBasisAntlrLexer;
import de.monticore.lang.sdbasis._symboltable.ISDBasisArtifactScope;
import de.monticore.lang.sdbasis._symboltable.SDBasisGlobalScope;
import de.monticore.lang.sdbasis._symboltable.ISDBasisArtifactScope;
import de.monticore.lang.sdbasis.SDBasisMill;
import de.monticore.io.paths.MCPath;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import de.monticore.symboltable.IGlobalScope;
import de.se_rwth.commons.logging.Finding;
import de.mclsg.lsp.LanguageServerWriteLock;

import java.util.*;
import de.se_rwth.commons.logging.Log;
import java.util.function.Consumer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.concurrent.atomic.AtomicReference;

public class SDBasisScopeManager{
	private static final Logger logger = LoggerFactory.getLogger(SDBasisScopeManager.class);
	private SDBasisGlobalScope globalScope = null;

	protected void setGlobalScope(SDBasisGlobalScope globalScope){
			this.globalScope = globalScope;
	}

 	public void initGlobalScope(MCPath modelPath) {
		SDBasisGlobalScope globalScope = (SDBasisGlobalScope) SDBasisMill.globalScope();
		globalScope.clear();
		globalScope.setSymbolPath(modelPath);
		setGlobalScope(globalScope);
	}

	public void resetGlobalScope(MCPath modelPath){
			syncAccessGlobalScope(gs -> gs.clear());
			initGlobalScope(modelPath);
	}

	public void clearGlobalScope(){
		syncAccessGlobalScope(gs -> resetGlobalScope(gs.getSymbolPath()));
	}

	/**
	 * Provides access to the GlobalScope, only in a synchronized manner.
	 * @param action The function to be executed on the GlobalScope.
	 */
	public void syncAccessGlobalScope(Consumer<SDBasisGlobalScope> action){
    try(var l = LanguageServerWriteLock.waitForLock()){
      action.accept(globalScope);
    }catch(InterruptedException e){
      logger.warn("Can not acquire lock in syncAccessGlobalScope", e);
    }
	}

	/**
	* Signals if the GlobalScope of this language can be created step by step via {@link #createArtifactScope()}, or if it needs to be created all at once via {@link #createAllArtifactScopes()}.
	* Should be overwritten to match the semantics of the language.
	*/
	public boolean supportsIterativeScopeAppending(){
		return true;
	}

	/**
	* Creates the artifact symbol for one ast element of the artifact level.
	* Should only be used if {@link #supportsIterativeScopeAppending()} returns true.
	* Adapt this method via the TOP-mechanism if the ScopeGenitorDelegator does not execute all steps needed to create the symbols.
	* Will remove the oldArtifactScope from the GlobalScope, if not null.
	* Must internally synchronize on the global scope.
	*/
	public SDBasisArtifactScopeWithFindings createArtifactScope(ASTSDArtifact ast, ISDBasisArtifactScope oldArtifactScope){
		Log.getFindings().clear();
		AtomicReference<ISDBasisArtifactScope> scopeRef = new AtomicReference<>(null);

		// Synchronize on the global scope, since the ScopesGenitorDelegator will use it
		syncAccessGlobalScope(gs -> {
			if(oldArtifactScope != null){
				gs.removeSubScope(oldArtifactScope);
			}
			try{
				scopeRef.set(SDBasisMill.scopesGenitorDelegator().createFromAST(ast));
			}catch(Exception e){
				// Symbol table creation is often written without error-handling after Log.error is used.
				// => We catch all exceptions here and send a message to the user
				if(ast.isPresent_SourcePositionStart()){
					// Passed to lsp client
					Log.error("Unknown error", ast.get_SourcePositionStart());
					// Written to log
					logger.error("Error while creating the symbol table", e);
				}
			}
		});

		return new SDBasisArtifactScopeWithFindings(
			ast,
			scopeRef.get(),
			Log.getFindings()
			);
    }

	public Map<ASTSDArtifact, SDBasisArtifactScopeWithFindings> createAllArtifactScopes(Collection<ASTSDArtifact> astNodes){
		final Map<ASTSDArtifact, SDBasisArtifactScopeWithFindings> res = new HashMap<>();
		syncAccessGlobalScope(gs -> {
			clearGlobalScope();
			if(supportsIterativeScopeAppending()){
				for(ASTSDArtifact node : astNodes){
					Log.getFindings().clear();
					res.put(node, createArtifactScope(node, null));
				}
			} else {
				// TODO: print warning only once
				logger.warn("createAllArtifactScopes is not implemented. Please provide an implementation via the TOP-mechanism on SDBasisScopeManager");
			}
		});
		return res;
	}
}