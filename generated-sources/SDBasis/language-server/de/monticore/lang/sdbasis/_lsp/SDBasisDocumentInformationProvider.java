/* generated by template _lsp.DocumentInformationProvider*/

package de.monticore.lang.sdbasis._lsp;

import de.monticore.lang.sdbasis._ast.ASTSDArtifact;
import de.monticore.lang.sdbasis._lsp.features.completion.SDBasisSymbolCollection;
import de.monticore.lang.sdbasis._lsp.features.completion.SDBasisSymbolCollector;
import de.monticore.lang.sdbasis._lsp.language_access.*;
import de.monticore.lang.sdbasis._lsp.*;
import de.monticore.lang.sdbasis._symboltable.ISDBasisArtifactScope;
import de.monticore.lang.sdbasis._symboltable.SDBasisGlobalScope;
import de.monticore.lang.sdbasis._symboltable.ICommonSDBasisSymbol;
import de.monticore.symboltable.ISymbol;
import de.mclsg.lsp.document_management.*;
import de.se_rwth.commons.logging.Log;
import org.eclipse.lsp4j.Diagnostic;
import org.eclipse.lsp4j.TextDocumentItem;
import de.mclsg.SeCommonsLogParser;
import de.mclsg.lsp.ChangeSource;

import java.util.*;
import java.util.stream.Collectors;
import de.mclsg.PositionUtils;
import de.mclsg.SeCommonsLogParser;
import java.util.stream.Collectors;
import java.util.concurrent.atomic.AtomicReference;
import java.lang.AutoCloseable;

import de.se_rwth.commons.logging.Finding;

import java.net.URI;
import de.mclsg.UriUtils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SDBasisDocumentInformationProvider implements DocumentInformationProvider {
  private static final Logger logger = LoggerFactory.getLogger(SDBasisDocumentInformationProvider.class);
  protected final SDBasisLanguageAccess languageAccess;
  protected DocumentManager documentManager;
  protected final SeCommonsLogParser logParser;

  public SDBasisDocumentInformationProvider(DocumentManager documentManager, SeCommonsLogParser logParser, SDBasisLanguageAccess languageAccess) {
    this.documentManager = documentManager;
    this.logParser = logParser;
    this.languageAccess = languageAccess;
  }

  protected DocumentInformation prepareDocumentInformation(TextDocumentItem documentItem){
    // User LSP Logger such that parser Errors are not logged into Log
    SDBasisLspAntlrParser parser = this.languageAccess.getLspParser(documentItem.getText());
    ASTSDArtifact ast = parser.sDArtifact().ret;

    DocumentInformation documentInformation = new DocumentInformation();
    documentInformation.uri = de.mclsg.UriUtils.toNormalizedFileUri(documentItem.getUri()).toString();
    documentInformation.ast = ast;
    documentInformation.languageId = "SDBasis";
    documentInformation.parseErrors.addAll(parser.getLspErrorListener().getErrors());
    documentInformation.matchedTokens = parser.getMatchedTokens();
    documentInformation.matchedTokens.forEach(mt -> mt.uri = documentInformation.uri);
    return documentInformation;
  }

  @Override
  public void createAllDocumentInformation(Collection<TextDocumentItem> items, ChangeSource changeSource){
    try(var c = documentManager.waitForLock()){
      logger.debug("Got lock for createAllDocumentInformation");
      Log.getFindings().clear();
      Log.enableFailQuick(false); // Server application => can not get shut down on the first error

      languageAccess.getScopeManager().clearGlobalScope();
      documentManager.reset(new SDBasisDocumentInformationFilter());

      for(TextDocumentItem documentItem : items){
        documentManager.addDocument(documentItem, changeSource);
        DocumentInformation documentInformation = prepareDocumentInformation(documentItem);
        documentManager.updateDocumentInformation(documentInformation);
      }

      Map<ASTSDArtifact, SDBasisArtifactScopeWithFindings> res = new HashMap<>();
      List<ASTSDArtifact> input = documentManager
        .getAllDocumentInformation(new SDBasisDocumentInformationFilter())
        .stream()
        .filter(di -> di.parseErrors.isEmpty())
        .map(di -> (ASTSDArtifact) di.ast)
        .collect(Collectors.toList());
      res.putAll(languageAccess.getScopeManager().createAllArtifactScopes(input));
      // All CoCos must be run after
      documentManager.getAllDocumentInformation(di -> true).forEach(di -> { di.findings.clear(); });

      postprocessing(res);
      logger.debug("Releasing lock for createAllDocumentInformation");
    }catch(InterruptedException e){
      logger.warn("Can not lock the documentManager", e);
      Log.error("Internal error while updating the documents");
    }
  }

  @Override
  public void updateAllDocumentInformation(TextDocumentItem documentItem) {
    try(var c = documentManager.waitForLock()){
      logger.debug("Got lock for updateAllDocumentInformation");
      Optional<DocumentInformation> oldDi = documentManager.getDocumentInformation(documentItem);
      Optional<ISDBasisArtifactScope> oldArtifactScope = oldDi
        .map(di -> {
          AtomicReference<ISDBasisArtifactScope> ref = new AtomicReference<>();
          di.syncAccessArtifactScope(asOpt -> ref.set((ISDBasisArtifactScope) asOpt.orElse(null)));
          return ref.get();
        });

      // Try to build symboltable every time also if there are syntax errors goto definition can work for example.
      Log.getFindings().clear();
      Log.enableFailQuick(false); // Server application => can not get shut down on the first error

      SDBasisScopeManager scopeManager = languageAccess.getScopeManager();
      DocumentInformation documentInformation = prepareDocumentInformation(documentItem);
      documentManager.updateDocumentInformation(documentInformation);

      Map<ASTSDArtifact, SDBasisArtifactScopeWithFindings> res = new HashMap<>();
      Map<ASTSDArtifact, List<Finding>> findingsPerDocument = new HashMap<>();
      if(scopeManager.supportsIterativeScopeAppending()){
        documentInformation.findings.clear();
        if(documentInformation.parseErrors.isEmpty()){
          res.put(
            (ASTSDArtifact) documentInformation.ast,
            scopeManager.createArtifactScope((ASTSDArtifact) documentInformation.ast, oldArtifactScope.orElse(null))
          );
        } else {
          if(oldArtifactScope.isPresent()){
            // Keep old artifact scope to provide approximately correct features
            // and to keep track of the oldArtifactScope(and replace it once no parser errors occur)
            res.put(
              (ASTSDArtifact) documentInformation.ast,
              new SDBasisArtifactScopeWithFindings(
                (ASTSDArtifact) oldDi.get().ast,
                oldArtifactScope.orElse(null),
                oldDi.get().findings
              )
            );
          }
        }
      }else{
        languageAccess.getScopeManager().clearGlobalScope();
        // All CoCos must be run after
        documentManager.getAllDocumentInformation(di -> true).forEach(di -> { di.findings.clear(); });
        List<ASTSDArtifact> input = documentManager
          .getAllDocumentInformation(new SDBasisDocumentInformationFilter())
          .stream()
          .filter(di -> di.parseErrors.isEmpty())
          .map(di -> (ASTSDArtifact) di.ast)
          .collect(Collectors.toList());
        res.putAll(scopeManager.createAllArtifactScopes(input));
      }

      postprocessing(res);
      logger.debug("Releasing lock for updateAllDocumentInformation");
    }catch(InterruptedException e){
      logger.warn("Can not lock the documentManager", e);
      Log.error("Internal error while updating the documents");
    }
  }

  protected void postprocessing(Map<ASTSDArtifact, SDBasisArtifactScopeWithFindings> res){
    List<de.se_rwth.commons.logging.Finding> findings = new ArrayList<>(Log.getFindings());
    Log.getFindings().clear();

    documentManager.getAllDocumentInformation(new SDBasisDocumentInformationFilter()).forEach(di -> {
      if(res.containsKey(di.ast)){
        languageAccess.getScopeManager().syncAccessGlobalScope((globalScope) -> {
          di.setGlobalScope(globalScope);
				  if(res.containsKey(di.ast)){
					  di.setArtifactScope(res.get(di.ast).scope);
					  di.findings.addAll(res.get(di.ast).findings);
				  }else{
					  logger.warn("Can not find artifact scope for " + di.uri);
				  }
        });

        di.syncAccessArtifactScope(artifactScope -> {
          if(artifactScope.isPresent()){
            di.symbols.addAll(getSymbols((ASTSDArtifact)di.ast, (ISDBasisArtifactScope)artifactScope.get()));
          }
        });

        documentManager.updateDocumentInformation(di);
      }else{
        logger.debug("No new info for {}", di.uri);
      }
    });
  }

  protected List<? extends ISymbol> getSymbols(ASTSDArtifact ast, ISDBasisArtifactScope artifactScope) {
    SDBasisSymbolCollector collector = new SDBasisSymbolCollector();
    SDBasisSymbolCollection symbolCollection = collector.collectSymbolsFromSymbolTable(ast, artifactScope);
    return symbolCollection.getAllSymbols();
  }
}
