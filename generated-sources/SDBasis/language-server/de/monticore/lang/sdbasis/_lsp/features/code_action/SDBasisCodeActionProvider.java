/* generated by template _lsp.features.code_action.CodeActionProvider*/

package de.monticore.lang.sdbasis._lsp.features.code_action;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import de.mclsg.PositionUtils;
import de.mclsg.lsp.document_management.DocumentInformation;
import de.mclsg.lsp.document_management.DocumentManager;
import de.mclsg.lsp.features.CodeActionProvider;
import de.mclsg.lsp.features.code_action.InvalidDataFormatException;
import de.monticore.ast.ASTNode;
import de.monticore.logging.FindingWithFix;
import de.monticore.logging.FixForFinding;
import de.monticore.prettyprint.AstPrettyPrinter;
import de.se_rwth.commons.logging.Finding;
import org.eclipse.lsp4j.*;
import org.eclipse.lsp4j.jsonrpc.messages.Either;

import java.util.*;
import org.slf4j.LoggerFactory;
import org.slf4j.Logger;

import de.monticore.lang.sdbasis._ast.ASTSDArtifact;

public class SDBasisCodeActionProvider implements CodeActionProvider {
    private static final Logger logger = LoggerFactory.getLogger(SDBasisCodeActionProvider.class);
    protected final DocumentManager documentManager;
    protected final AstPrettyPrinter<ASTSDArtifact> prettyPrinter;

    public SDBasisCodeActionProvider(DocumentManager documentManager, AstPrettyPrinter<ASTSDArtifact> prettyPrinter) {
        this.documentManager = documentManager;
        this.prettyPrinter = prettyPrinter;
    }

    @Override
    public List<Either<Command, CodeAction>> codeAction(TextDocumentItem document, CodeActionContext context, Range range) {
        List<Either<Command, CodeAction>> res = new ArrayList<>();
        if (context.getDiagnostics() == null || context.getDiagnostics().isEmpty()) {
            return res;
        }

        Optional<DocumentInformation> diOpt = documentManager.getDocumentInformation(document);

        for (Diagnostic diagnostic : context.getDiagnostics()) {

            if (diOpt.isPresent()) {
                DocumentInformation di = diOpt.get();

                Map<Integer, FindingWithFix<? extends ASTNode>> findingsMap = new HashMap<>();
                for (Finding finding : di.findings) {
                    if (finding instanceof FindingWithFix) {
                        findingsMap.put(finding.hashCode(), (FindingWithFix<? extends ASTNode>) finding);
                    }
                }

                Object data = diagnostic.getData();
				try {
					List<Integer> findingIds = getFindingIds(data);
					for (Integer findingId : findingIds) {
						FindingWithFix<? extends ASTNode> f = findingsMap.get(findingId);
						if (f != null) {
							for (FixForFinding<? extends ASTNode> fix : f.getFixes()) {
								FixForFinding<ASTNode> fixAsASTNode = (FixForFinding<ASTNode>) fix;
								CodeAction ca = new CodeAction();
								ca.setTitle(fixAsASTNode.getTitle());

								Map<String, List<TextEdit>> editsMap = new HashMap<>();

								Range r = new Range(new Position(0, 0), new Position(Integer.MAX_VALUE, 0));
								if(di.ast.isPresent_SourcePositionStart()){
									r.setStart(PositionUtils.toPosition(di.ast.get_SourcePositionStart()));
								}
								if(di.ast.isPresent_SourcePositionEnd()){
									r.setEnd(PositionUtils.toPosition(di.ast.get_SourcePositionEnd()));
								}

								String fixedContent = prettyPrinter.prettyPrint((ASTSDArtifact) fixAsASTNode.getFixedAST());
								editsMap.put(document.getUri(), Collections.singletonList(new TextEdit(r, fixedContent)));
								ca.setEdit(new WorkspaceEdit(editsMap));
								ca.setDiagnostics(Collections.singletonList(diagnostic));
								ca.setKind(CodeActionKind.QuickFix);
								res.add(Either.forRight(ca));
							}
						} else {
							logger.warn("Can not find Finding with id " + findingId);
						}
					}
				} catch (InvalidDataFormatException e) {
					logger.warn("Can not parse finding ids from Diagnostic#data = " + data, e);
				}
            } else {
                logger.info("QuickFixes: Can not find document information for " + document.getUri());
            }
        }

        return res;
    }

    protected List<Integer> getFindingIds(Object dataObj) throws InvalidDataFormatException {
      if(dataObj == null){
          return Collections.emptyList();
      }

    	if(!(dataObj instanceof JsonObject)){
    		throw new InvalidDataFormatException("data needs to be a JsonObject");
    	}
		JsonObject data = (JsonObject) dataObj;

        List<Integer> res = new ArrayList<>();
        JsonElement findings = data.get("findings");
        if (findings == null) throw new InvalidDataFormatException("data does not contain field 'findings'");
        if (!findings.isJsonArray()) throw new InvalidDataFormatException("field 'findings' is no JsonArray");
        JsonArray findingsAsArray = findings.getAsJsonArray();

        for (JsonElement jsonElement : findingsAsArray) {
            if (jsonElement.isJsonPrimitive() && jsonElement.getAsJsonPrimitive().isNumber()) {
                res.add(jsonElement.getAsJsonPrimitive().getAsInt());
            } else {
                throw new InvalidDataFormatException("Element of array 'findings' is not a number: " + jsonElement);
            }
        }

        return res;
    }
}