/* generated by template _lsp.LspAntlrParser*/

package de.monticore.lang.sdbasis._lsp;

import de.monticore.lang.sdbasis._lsp.features.completion.SDBasisExpectedTokenVisitor;
import de.monticore.lang.sdbasis._parser.SDBasisAntlrParser;
import de.mclsg.parser.LspErrorListener;
import de.mclsg.parser.LspParser;
import de.mclsg.parser.MatchedToken;
import de.monticore.ast.ASTNode;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenStream;
import org.eclipse.lsp4j.Position;
import org.eclipse.lsp4j.Range;
import org.antlr.v4.runtime.atn.Transition;
import org.antlr.v4.runtime.atn.ATNState;
import java.util.Arrays;
import java.util.stream.Collectors;

import de.mclsg.lsp.features.completion.strategy.TokenPath;
import org.antlr.v4.runtime.RuleContext;
import de.monticore.lang.sdbasis._parser.SDBasisParserInfo;

import java.util.*;

public class SDBasisLspAntlrParser extends SDBasisAntlrParser implements LspParser {
    private LspErrorListener lspErrorListener;
    protected List<MatchedToken> matchedTokens = new ArrayList<>();
    public Map<ParserRuleContext, Integer> numberOfMatchedTokensInRule = new HashMap<>();
	private SDBasisExpectedTokenVisitor expectedTokenVisitor;
    public SDBasisLspAntlrLexer lexer;

    public SDBasisLspAntlrParser(TokenStream input) {
        super(input);
        exchangeErrorListener();
    }

    private void exchangeErrorListener() {
        expectedTokenVisitor = new SDBasisExpectedTokenVisitor(this);
        lspErrorListener = new LspErrorListener(expectedTokenVisitor);
        removeErrorListeners(); // Remove MC Logger
        addErrorListener(lspErrorListener);
    }

    @Override
    public LspErrorListener getLspErrorListener() {
        return this.lspErrorListener;
    }

    public SDArtifactContext parse() {
        return sDArtifact();
    }

    @Override
    public ParserRuleContext getContext() {
        return this._ctx;
    }

	public SDBasisExpectedTokenVisitor getExpectedTokenVisitor(){
		return expectedTokenVisitor;
	}

    @Override
    public Token match(int ttype) throws RecognitionException {
        Token token = super.match(ttype);

		for(MatchedToken matchedToken : mapToMatchedTokens(token)){
			this.matchedTokens.add(matchedToken);
		}

        return token;
    }

	protected List<MatchedToken> mapToMatchedTokens(Token token){
    increaseMatchedTokenNumber(getContext());
		if (token.getType() == Name) {
			return Collections.singletonList(getTokenInformation(token, true));
		} else {
      return Collections.singletonList(getTokenInformation(token, false));
    }
	}

    @Override
    public boolean hasErrors() {
        LspErrorListener lspErrorListener = getLspErrorListener();
        return lspErrorListener.getErrors().size() > 0;
    }

    protected MatchedToken getTokenInformation(Token token, boolean isNameToken) {
        MatchedToken matchedToken = new MatchedToken();
				matchedToken.parserState = getState();
        matchedToken.token = token;
        matchedToken.range = getTokenRange(token);
        matchedToken.context = getContext();
        matchedToken.ruleIndex = getContext().getRuleIndex();
        matchedToken.tokenPath = getTokenPath(matchedToken.context);
        matchedToken.isLocalKeyword = matchedToken.tokenPathMatches(".*[.]nokeyword_.*\\d+(_eof)?");
        matchedToken.isNameToken = !matchedToken.isLocalKeyword && isNameToken;
				matchedToken.isDefiningName = SDBasisParserInfo.stateDefinesName(matchedToken.parserState);
        matchedToken.nextParserStates = Arrays.stream(getATN().states.get(getState()).getTransitions())
            .filter(t -> t.label().contains(token.getType()))
            .map(t -> t.target.stateNumber)
            .collect(Collectors.toList());

        return matchedToken;
    }

	private TokenPath getTokenPath(RuleContext context) {
		TokenPath tokenPath = new TokenPath();
		RuleContext iteratedContext = context;
		while (iteratedContext != null) {
			if (iteratedContext.getRuleIndex() < 0) {
				break;
			}
			tokenPath.tokenPathElements.add(getRuleNames()[iteratedContext.getRuleIndex()]);
			iteratedContext = iteratedContext.parent;
		}
		Collections.reverse(tokenPath.tokenPathElements);
		return tokenPath;
	}

    private Range getTokenRange(Token token) {
        Position startPosition = new Position(token.getLine() - 1, token.getCharPositionInLine());
        int length = token.getText().length();
        Position endPosition = new Position(token.getLine() - 1, token.getCharPositionInLine() + length);
        return new Range(startPosition, endPosition);
    }

    @Override
    public void enterRule(ParserRuleContext localctx, int state, int ruleIndex) {
        super.enterRule(localctx, state, ruleIndex);
        this.numberOfMatchedTokensInRule.put(localctx, 0);
    }

    protected Integer getPositionOfLastTokenInRule(ParserRuleContext ruleContext) {
        return this.numberOfMatchedTokensInRule.get(ruleContext) - 1;
    }

    protected void increaseMatchedTokenNumber(ParserRuleContext context) {
    	if(!this.numberOfMatchedTokensInRule.containsKey(context)){
    		this.numberOfMatchedTokensInRule.put(context, 0);
        }
		this.numberOfMatchedTokensInRule.put(context, this.numberOfMatchedTokensInRule.get(context) + 1);
    }

    @Override
    public List<MatchedToken> getMatchedTokens() {
        return this.matchedTokens;
    }

    @Override
    public ASTNode getActiveASTNode() {
        return activeastnode;
    }

    public ATNState getFirstState() {
        return getATN().ruleToStartState[RULE_sDArtifact];
    }
}
